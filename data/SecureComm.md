**Notation:**
- A, B: Alice (Client) and Bob (Server)
- {X}K: X encrypted with key K
- [X]K: X signed with key K
- H(X): Cryptographic hash of X
- N_A, N_B: Nonces generated by A and B
- g^x, g^y: Diffie-Hellman public values
- SK: Negotiated session key

**Security Goals:**
- Mutual Authentication
- Confidentiality of messages
- Integrity of messages
- Non-repudiation of origin

**Assumptions:**
- A and B have a pre-shared secret key (PSK) or certificate authority (CA) for authentication
- Diffie-Hellman parameters and cryptographic algorithms are negotiated out-of-band
- A and B have access to each other's public keys for digital signatures

**Message Flow:**

```
A -> B: A, N_A
B -> A: B, N_B, {B_cert}PSK
A -> B: A_cert, [g^x]pvt(A), {N_A, N_B, A, B}pvt(A)
B -> A: [g^y]pvt(B), {N_A, N_B, B, A}pvt(B)

[Both A and B calculate the shared secret SK = g^(xy)]

A -> B: {Data_A}SK, [H(Data_A)]pvt(A)
B -> A: {Data_B}SK, [H(Data_B)]pvt(B)
```

**Message Formats:**

1. `A -> B: A, N_A`
   - A: Client identifier
   - N_A: Nonce generated by A

2. `B -> A: B, N_B, {B_cert}PSK`
   - B: Server identifier
   - N_B: Nonce generated by B
   - {B_cert}PSK: Server's certificate encrypted with pre-shared key

3. `A -> B: A_cert, [g^x]pvt(A), {N_A, N_B, A, B}pvt(A)`
   - A_cert: Client's certificate
   - [g^x]pvt(A): Client's Diffie-Hellman public value signed with A's private key
   - {N_A, N_B, A, B}pvt(A): Nonces, identifiers signed with A's private key

4. `B -> A: [g^y]pvt(B), {N_A, N_B, B, A}pvt(B)`
   - [g^y]pvt(B): Server's Diffie-Hellman public value signed with B's private key
   - {N_A, N_B, B, A}pvt(B): Nonces, identifiers signed with B's private key

5. `A -> B: {Data_A}SK, [H(Data_A)]pvt(A)`
   - {Data_A}SK: Data from A encrypted with session key
   - [H(Data_A)]pvt(A): Hash of Data_A signed with A's private key

6. `B -> A: {Data_B}SK, [H(Data_B)]pvt(B)`
   - {Data_B}SK: Data from B encrypted with session key
   - [H(Data_B)]pvt(B): Hash of Data_B signed with B's private key

**State Transition Diagrams:**

```
Client (A) State Transition:

Start -> Send(A, N_A) -> Recv(B, N_B, {B_cert}PSK)
           |
           | if B_cert is valid
           v
         Send(A_cert, [g^x]pvt(A), {N_A, N_B, A, B}pvt(A)) -> Recv([g^y]pvt(B), {N_A, N_B, B, A}pvt(B))
           |
           | if g^y and signature are valid
           | calculate SK = g^(xy)
           v
         Send({Data_A}SK, [H(Data_A)]pvt(A)) -> Recv({Data_B}SK, [H(Data_B)]pvt(B))
           |
           | if MAC is valid
           v
         End

Server (B) State Transition:

Start -> Recv(A, N_A) -> Send(B, N_B, {B_cert}PSK)
           |
           v
         Recv(A_cert, [g^x]pvt(A), {N_A, N_B, A, B}pvt(A)) -> if A_cert and signatures are valid
           |
           v
         Send([g^y]pvt(B), {N_A, N_B, B, A}pvt(B)) -> calculate SK = g^(xy)
           |
           v
         Recv({Data_A}SK, [H(Data_A)]pvt(A)) -> if MAC is valid
           |
           v
         Send({Data_B}SK, [H(Data_B)]pvt(B))
           |
           v
         End
```
